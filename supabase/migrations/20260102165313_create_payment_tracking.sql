-- ============================================
-- Create Payment Tracking Tables Migration
-- ============================================

-- Create payment_packages table
CREATE TABLE IF NOT EXISTS "public"."payment_packages" (
    "id" bigint generated by default as identity not null,
    "patient_id" bigint not null,
    "service_id" bigint,
    "package_type" text not null,
    "total_amount" numeric(10, 2) not null,
    "price_per_hour" numeric(10, 2),
    "total_sessions" integer,
    "total_hours" numeric(10, 2),
    "duration_days" integer,
    "hours_per_day" numeric(5, 2),
    "start_date" date not null,
    "end_date" date,
    "renewal_date" date,
    "status" text not null default 'active',
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    PRIMARY KEY ("id")
);

-- Enable RLS
ALTER TABLE "public"."payment_packages" ENABLE ROW LEVEL SECURITY;

-- Add foreign key constraints for payment_packages
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'payment_packages_patient_id_fkey'
    ) THEN
        ALTER TABLE "public"."payment_packages" 
        ADD CONSTRAINT "payment_packages_patient_id_fkey" 
        FOREIGN KEY (patient_id) 
        REFERENCES contacts(id) 
        ON UPDATE CASCADE 
        ON DELETE CASCADE;
    END IF;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'payment_packages_service_id_fkey'
    ) THEN
        ALTER TABLE "public"."payment_packages" 
        ADD CONSTRAINT "payment_packages_service_id_fkey" 
        FOREIGN KEY (service_id) 
        REFERENCES services(id) 
        ON UPDATE CASCADE 
        ON DELETE SET NULL;
    END IF;
END $$;

-- Create policies for payment_packages
CREATE POLICY "Enable read access for authenticated users"
ON "public"."payment_packages"
AS PERMISSIVE
FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Enable insert for authenticated users"
ON "public"."payment_packages"
AS PERMISSIVE
FOR INSERT
TO authenticated
WITH CHECK (true);

CREATE POLICY "Enable update for authenticated users"
ON "public"."payment_packages"
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (true);

CREATE POLICY "Enable delete for authenticated users"
ON "public"."payment_packages"
AS PERMISSIVE
FOR DELETE
TO authenticated
USING (true);

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."payment_packages" TO "authenticated";
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."payment_packages" TO "service_role";

-- Create indexes for faster queries
CREATE INDEX IF NOT EXISTS "payment_packages_patient_id_idx" ON "public"."payment_packages" ("patient_id");
CREATE INDEX IF NOT EXISTS "payment_packages_status_idx" ON "public"."payment_packages" ("status");
CREATE INDEX IF NOT EXISTS "payment_packages_renewal_date_idx" ON "public"."payment_packages" ("renewal_date");
CREATE INDEX IF NOT EXISTS "payment_packages_service_id_idx" ON "public"."payment_packages" ("service_id");
CREATE INDEX IF NOT EXISTS "payment_packages_package_type_idx" ON "public"."payment_packages" ("package_type");

-- Add check constraints for valid values
ALTER TABLE "public"."payment_packages" 
ADD CONSTRAINT "payment_packages_package_type_check" 
CHECK (package_type IN ('session-based', 'time-based', 'post-payment'));

ALTER TABLE "public"."payment_packages" 
ADD CONSTRAINT "payment_packages_status_check" 
CHECK (status IN ('active', 'completed', 'expired'));

-- Add trigger to update updated_at timestamp
CREATE TRIGGER update_payment_packages_updated_at BEFORE UPDATE ON "public"."payment_packages"
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Create payment_transactions table
CREATE TABLE IF NOT EXISTS "public"."payment_transactions" (
    "id" bigint generated by default as identity not null,
    "payment_package_id" bigint not null,
    "amount_received" numeric(10, 2) not null,
    "bank_charge" numeric(10, 2) not null default 0.00,
    "net_amount" numeric(10, 2) not null,
    "payment_method" text not null,
    "date_paid" date not null,
    "date_received" date not null,
    "invoice_number" text,
    "installment_number" integer,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    PRIMARY KEY ("id")
);

-- Enable RLS
ALTER TABLE "public"."payment_transactions" ENABLE ROW LEVEL SECURITY;

-- Add foreign key constraint for payment_transactions
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'payment_transactions_payment_package_id_fkey'
    ) THEN
        ALTER TABLE "public"."payment_transactions" 
        ADD CONSTRAINT "payment_transactions_payment_package_id_fkey" 
        FOREIGN KEY (payment_package_id) 
        REFERENCES payment_packages(id) 
        ON UPDATE CASCADE 
        ON DELETE CASCADE;
    END IF;
END $$;

-- Create policies for payment_transactions
CREATE POLICY "Enable read access for authenticated users"
ON "public"."payment_transactions"
AS PERMISSIVE
FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Enable insert for authenticated users"
ON "public"."payment_transactions"
AS PERMISSIVE
FOR INSERT
TO authenticated
WITH CHECK (true);

CREATE POLICY "Enable update for authenticated users"
ON "public"."payment_transactions"
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (true);

CREATE POLICY "Enable delete for authenticated users"
ON "public"."payment_transactions"
AS PERMISSIVE
FOR DELETE
TO authenticated
USING (true);

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."payment_transactions" TO "authenticated";
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."payment_transactions" TO "service_role";

-- Create indexes for faster queries
CREATE INDEX IF NOT EXISTS "payment_transactions_payment_package_id_idx" ON "public"."payment_transactions" ("payment_package_id");
CREATE INDEX IF NOT EXISTS "payment_transactions_payment_method_idx" ON "public"."payment_transactions" ("payment_method");
CREATE INDEX IF NOT EXISTS "payment_transactions_date_paid_idx" ON "public"."payment_transactions" ("date_paid");
CREATE INDEX IF NOT EXISTS "payment_transactions_invoice_number_idx" ON "public"."payment_transactions" ("invoice_number");

-- Add check constraints for valid values
ALTER TABLE "public"."payment_transactions" 
ADD CONSTRAINT "payment_transactions_payment_method_check" 
CHECK (payment_method IN ('POS', 'Tabby', 'Payment Link', 'Ziina', 'Cash'));

-- Add check constraint to ensure net_amount = amount_received - bank_charge
ALTER TABLE "public"."payment_transactions" 
ADD CONSTRAINT "payment_transactions_net_amount_check" 
CHECK (net_amount = amount_received - bank_charge);

-- Add trigger to update updated_at timestamp
CREATE TRIGGER update_payment_transactions_updated_at BEFORE UPDATE ON "public"."payment_transactions"
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Create payment_settings table
CREATE TABLE IF NOT EXISTS "public"."payment_settings" (
    "id" bigint generated by default as identity not null,
    "payment_method" text not null,
    "fee_percentage" numeric(5, 2),
    "fixed_fee_amount" numeric(10, 2),
    "vat_percentage" numeric(5, 2) not null default 5.00,
    "is_active" boolean not null default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    PRIMARY KEY ("id"),
    UNIQUE ("payment_method")
);

-- Enable RLS
ALTER TABLE "public"."payment_settings" ENABLE ROW LEVEL SECURITY;

-- Create policies for payment_settings
CREATE POLICY "Enable read access for authenticated users"
ON "public"."payment_settings"
AS PERMISSIVE
FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Enable insert for authenticated users"
ON "public"."payment_settings"
AS PERMISSIVE
FOR INSERT
TO authenticated
WITH CHECK (true);

CREATE POLICY "Enable update for authenticated users"
ON "public"."payment_settings"
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (true);

CREATE POLICY "Enable delete for authenticated users"
ON "public"."payment_settings"
AS PERMISSIVE
FOR DELETE
TO authenticated
USING (true);

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."payment_settings" TO "authenticated";
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."payment_settings" TO "service_role";

-- Create index for faster queries
CREATE INDEX IF NOT EXISTS "payment_settings_payment_method_idx" ON "public"."payment_settings" ("payment_method");
CREATE INDEX IF NOT EXISTS "payment_settings_is_active_idx" ON "public"."payment_settings" ("is_active");

-- Add check constraints for valid values
ALTER TABLE "public"."payment_settings" 
ADD CONSTRAINT "payment_settings_payment_method_check" 
CHECK (payment_method IN ('POS', 'Tabby', 'Payment Link', 'Ziina', 'Cash'));

ALTER TABLE "public"."payment_settings" 
ADD CONSTRAINT "payment_settings_fee_percentage_check" 
CHECK (fee_percentage IS NULL OR (fee_percentage >= 0 AND fee_percentage <= 100));

ALTER TABLE "public"."payment_settings" 
ADD CONSTRAINT "payment_settings_fixed_fee_amount_check" 
CHECK (fixed_fee_amount IS NULL OR fixed_fee_amount >= 0);

ALTER TABLE "public"."payment_settings" 
ADD CONSTRAINT "payment_settings_vat_percentage_check" 
CHECK (vat_percentage >= 0 AND vat_percentage <= 100);

-- Add trigger to update updated_at timestamp
CREATE TRIGGER update_payment_settings_updated_at BEFORE UPDATE ON "public"."payment_settings"
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Create package_usage table
CREATE TABLE IF NOT EXISTS "public"."package_usage" (
    "id" bigint generated by default as identity not null,
    "payment_package_id" bigint not null,
    "appointment_id" bigint,
    "usage_type" text not null,
    "quantity_used" numeric(10, 2) not null,
    "usage_date" date not null,
    "is_manual_adjustment" boolean not null default false,
    "notes" text,
    "created_at" timestamp with time zone not null default now(),
    PRIMARY KEY ("id")
);

-- Enable RLS
ALTER TABLE "public"."package_usage" ENABLE ROW LEVEL SECURITY;

-- Add foreign key constraints for package_usage
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'package_usage_payment_package_id_fkey'
    ) THEN
        ALTER TABLE "public"."package_usage" 
        ADD CONSTRAINT "package_usage_payment_package_id_fkey" 
        FOREIGN KEY (payment_package_id) 
        REFERENCES payment_packages(id) 
        ON UPDATE CASCADE 
        ON DELETE CASCADE;
    END IF;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'package_usage_appointment_id_fkey'
    ) THEN
        ALTER TABLE "public"."package_usage" 
        ADD CONSTRAINT "package_usage_appointment_id_fkey" 
        FOREIGN KEY (appointment_id) 
        REFERENCES appointments(id) 
        ON UPDATE CASCADE 
        ON DELETE SET NULL;
    END IF;
END $$;

-- Create policies for package_usage
CREATE POLICY "Enable read access for authenticated users"
ON "public"."package_usage"
AS PERMISSIVE
FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Enable insert for authenticated users"
ON "public"."package_usage"
AS PERMISSIVE
FOR INSERT
TO authenticated
WITH CHECK (true);

CREATE POLICY "Enable update for authenticated users"
ON "public"."package_usage"
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (true);

CREATE POLICY "Enable delete for authenticated users"
ON "public"."package_usage"
AS PERMISSIVE
FOR DELETE
TO authenticated
USING (true);

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."package_usage" TO "authenticated";
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."package_usage" TO "service_role";

-- Create indexes for faster queries
CREATE INDEX IF NOT EXISTS "package_usage_payment_package_id_idx" ON "public"."package_usage" ("payment_package_id");
CREATE INDEX IF NOT EXISTS "package_usage_appointment_id_idx" ON "public"."package_usage" ("appointment_id");
CREATE INDEX IF NOT EXISTS "package_usage_usage_type_idx" ON "public"."package_usage" ("usage_type");
CREATE INDEX IF NOT EXISTS "package_usage_usage_date_idx" ON "public"."package_usage" ("usage_date");

-- Add check constraints for valid values
ALTER TABLE "public"."package_usage" 
ADD CONSTRAINT "package_usage_usage_type_check" 
CHECK (usage_type IN ('session', 'hours'));

ALTER TABLE "public"."package_usage" 
ADD CONSTRAINT "package_usage_quantity_used_check" 
CHECK (quantity_used > 0);

-- Create installment_schedules table
CREATE TABLE IF NOT EXISTS "public"."installment_schedules" (
    "id" bigint generated by default as identity not null,
    "payment_package_id" bigint not null,
    "installment_number" integer not null,
    "due_date" date not null,
    "amount_due" numeric(10, 2) not null,
    "is_paid" boolean not null default false,
    "paid_date" date,
    "reminder_sent" boolean not null default false,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    PRIMARY KEY ("id")
);

-- Enable RLS
ALTER TABLE "public"."installment_schedules" ENABLE ROW LEVEL SECURITY;

-- Add foreign key constraint for installment_schedules
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'installment_schedules_payment_package_id_fkey'
    ) THEN
        ALTER TABLE "public"."installment_schedules" 
        ADD CONSTRAINT "installment_schedules_payment_package_id_fkey" 
        FOREIGN KEY (payment_package_id) 
        REFERENCES payment_packages(id) 
        ON UPDATE CASCADE 
        ON DELETE CASCADE;
    END IF;
END $$;

-- Create policies for installment_schedules
CREATE POLICY "Enable read access for authenticated users"
ON "public"."installment_schedules"
AS PERMISSIVE
FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Enable insert for authenticated users"
ON "public"."installment_schedules"
AS PERMISSIVE
FOR INSERT
TO authenticated
WITH CHECK (true);

CREATE POLICY "Enable update for authenticated users"
ON "public"."installment_schedules"
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (true);

CREATE POLICY "Enable delete for authenticated users"
ON "public"."installment_schedules"
AS PERMISSIVE
FOR DELETE
TO authenticated
USING (true);

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."installment_schedules" TO "authenticated";
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE "public"."installment_schedules" TO "service_role";

-- Create indexes for faster queries
CREATE INDEX IF NOT EXISTS "installment_schedules_payment_package_id_idx" ON "public"."installment_schedules" ("payment_package_id");
CREATE INDEX IF NOT EXISTS "installment_schedules_due_date_idx" ON "public"."installment_schedules" ("due_date");
CREATE INDEX IF NOT EXISTS "installment_schedules_is_paid_idx" ON "public"."installment_schedules" ("is_paid");

-- Add check constraints for valid values
ALTER TABLE "public"."installment_schedules" 
ADD CONSTRAINT "installment_schedules_installment_number_check" 
CHECK (installment_number > 0);

ALTER TABLE "public"."installment_schedules" 
ADD CONSTRAINT "installment_schedules_amount_due_check" 
CHECK (amount_due > 0);

-- Add unique constraint to ensure one installment per number per package
ALTER TABLE "public"."installment_schedules" 
ADD CONSTRAINT "installment_schedules_package_installment_unique" 
UNIQUE ("payment_package_id", "installment_number");

-- Add trigger to update updated_at timestamp
CREATE TRIGGER update_installment_schedules_updated_at BEFORE UPDATE ON "public"."installment_schedules"
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- Add payment_package_id to appointments table
-- ============================================
-- Add payment_package_id column to appointments for linking appointments to payment packages
ALTER TABLE "public"."appointments" 
ADD COLUMN IF NOT EXISTS "payment_package_id" bigint;

-- Add foreign key constraint for payment_package_id
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'appointments_payment_package_id_fkey'
    ) THEN
        ALTER TABLE "public"."appointments" 
        ADD CONSTRAINT "appointments_payment_package_id_fkey" 
        FOREIGN KEY (payment_package_id) 
        REFERENCES payment_packages(id) 
        ON UPDATE CASCADE 
        ON DELETE SET NULL;
    END IF;
END $$;

-- Add index for faster queries
CREATE INDEX IF NOT EXISTS "appointments_payment_package_id_idx" ON "public"."appointments" ("payment_package_id");

-- ============================================
-- Database Functions
-- ============================================

-- Function to calculate package usage (sessions and hours used)
CREATE OR REPLACE FUNCTION calculate_package_usage(package_id bigint)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    result jsonb;
    sessions_used numeric := 0;
    hours_used numeric := 0;
BEGIN
    -- Calculate sessions used (for session-based packages)
    SELECT COALESCE(SUM(quantity_used), 0)
    INTO sessions_used
    FROM package_usage
    WHERE payment_package_id = package_id
      AND usage_type = 'session';

    -- Calculate hours used (for time-based packages)
    SELECT COALESCE(SUM(quantity_used), 0)
    INTO hours_used
    FROM package_usage
    WHERE payment_package_id = package_id
      AND usage_type = 'hours';

    -- Return JSON with usage totals
    result := jsonb_build_object(
        'sessions_used', sessions_used,
        'hours_used', hours_used
    );

    RETURN result;
END;
$$;

-- Function to calculate hours from appointment start_time and end_time
CREATE OR REPLACE FUNCTION calculate_hours_from_appointment(appointment_id_param bigint)
RETURNS numeric
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    hours_result numeric;
    start_ts timestamp with time zone;
    end_ts timestamp with time zone;
BEGIN
    -- Get appointment start and end times
    SELECT start_time, end_time
    INTO start_ts, end_ts
    FROM appointments
    WHERE id = appointment_id_param;

    -- If appointment not found, return 0
    IF start_ts IS NULL OR end_ts IS NULL THEN
        RETURN 0;
    END IF;

    -- Calculate hours difference (can be decimal like 8.5)
    hours_result := EXTRACT(EPOCH FROM (end_ts - start_ts)) / 3600.0;

    RETURN hours_result;
END;
$$;

-- Function to calculate bank charge based on payment method settings
CREATE OR REPLACE FUNCTION calculate_bank_charge(
    amount_param numeric,
    payment_method_param text
)
RETURNS numeric
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    fee_pct numeric;
    fixed_fee numeric;
    vat_pct numeric;
    base_fee numeric;
    bank_charge_result numeric;
BEGIN
    -- Get payment settings for the method
    SELECT fee_percentage, fixed_fee_amount, vat_percentage
    INTO fee_pct, fixed_fee, vat_pct
    FROM payment_settings
    WHERE payment_method = payment_method_param
      AND is_active = true
    LIMIT 1;

    -- If settings not found, return 0
    IF fee_pct IS NULL AND fixed_fee IS NULL THEN
        RETURN 0;
    END IF;

    -- Calculate base fee: (amount × fee_percentage) + fixed_fee_amount
    base_fee := COALESCE((amount_param * COALESCE(fee_pct, 0) / 100), 0) + COALESCE(fixed_fee, 0);

    -- Add VAT: base_fee × (1 + vat_percentage/100)
    bank_charge_result := base_fee * (1 + COALESCE(vat_pct, 0) / 100);

    RETURN bank_charge_result;
END;
$$;

-- ============================================
-- Database Trigger for Auto-Tracking Usage
-- ============================================

-- Trigger function to update package usage when appointment status changes
CREATE OR REPLACE FUNCTION update_package_usage_on_appointment_change()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    package_record payment_packages%ROWTYPE;
    hours_used numeric;
    usage_exists boolean;
BEGIN
    -- Only process if status changed to 'completed' or 'cancelled'
    IF (NEW.status = 'completed' AND OLD.status != 'completed') OR
       (NEW.status = 'cancelled' AND OLD.status != 'cancelled') THEN

        -- Check if appointment is linked to a payment package
        IF NEW.payment_package_id IS NOT NULL THEN
            -- Get package details
            SELECT * INTO package_record
            FROM payment_packages
            WHERE id = NEW.payment_package_id
              AND status = 'active';

            -- If package found and active
            IF FOUND THEN
                -- Handle completed appointments
                IF NEW.status = 'completed' THEN
                    -- Check if usage record already exists for this appointment
                    SELECT EXISTS(
                        SELECT 1 FROM package_usage
                        WHERE appointment_id = NEW.id
                          AND payment_package_id = NEW.payment_package_id
                    ) INTO usage_exists;

                    -- Only create usage record if it doesn't exist
                    IF NOT usage_exists THEN
                        -- For session-based packages: add 1 session
                        IF package_record.package_type = 'session-based' THEN
                            INSERT INTO package_usage (
                                payment_package_id,
                                appointment_id,
                                usage_type,
                                quantity_used,
                                usage_date,
                                is_manual_adjustment
                            ) VALUES (
                                NEW.payment_package_id,
                                NEW.id,
                                'session',
                                1,
                                NEW.appointment_date,
                                false
                            );
                        -- For time-based packages: calculate hours and add
                        ELSIF package_record.package_type = 'time-based' THEN
                            hours_used := calculate_hours_from_appointment(NEW.id);
                            IF hours_used > 0 THEN
                                INSERT INTO package_usage (
                                    payment_package_id,
                                    appointment_id,
                                    usage_type,
                                    quantity_used,
                                    usage_date,
                                    is_manual_adjustment
                                ) VALUES (
                                    NEW.payment_package_id,
                                    NEW.id,
                                    'hours',
                                    hours_used,
                                    NEW.appointment_date,
                                    false
                                );
                            END IF;
                        END IF;
                    END IF;
                -- Handle cancelled appointments (remove usage for session-based only)
                ELSIF NEW.status = 'cancelled' AND OLD.status = 'completed' THEN
                    -- For session-based packages: remove the usage record
                    IF package_record.package_type = 'session-based' THEN
                        DELETE FROM package_usage
                        WHERE appointment_id = NEW.id
                          AND payment_package_id = NEW.payment_package_id
                          AND usage_type = 'session'
                          AND is_manual_adjustment = false;
                    END IF;
                END IF;
            END IF;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;

-- Create trigger on appointments table
DROP TRIGGER IF EXISTS update_package_usage_on_appointment_change ON "public"."appointments";

CREATE TRIGGER update_package_usage_on_appointment_change
    AFTER UPDATE OF status ON "public"."appointments"
    FOR EACH ROW
    WHEN (OLD.status IS DISTINCT FROM NEW.status)
    EXECUTE FUNCTION update_package_usage_on_appointment_change();

-- ============================================
-- Insert Default Payment Settings
-- ============================================

-- Insert default payment settings for all payment methods
INSERT INTO "public"."payment_settings" (payment_method, fee_percentage, fixed_fee_amount, vat_percentage, is_active)
VALUES
    ('POS', 1.9, NULL, 5.00, true),
    ('Payment Link', 2.9, 1.00, 5.00, true),
    ('Ziina', 2.6, 1.00, 5.00, true),
    ('Tabby', NULL, NULL, 5.00, true), -- Placeholder until fee structure provided
    ('Cash', 0, 0, 5.00, true)
ON CONFLICT (payment_method) DO NOTHING;

