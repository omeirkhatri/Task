import { useDataProvider, useGetIdentity, type DataProvider } from "ra-core";
import { useCallback, useMemo } from "react";

import { createLeadJourneyDealForContact } from "../deals/createLeadJourneyDeal";
import type { Company, Tag } from "../types";
import type { ImportError } from "../misc/usePapaParse";

export type ContactImportSchema = {
  // Auto-generated fields (ignored if present in CSV):
  // id - auto-generated by database
  // sales_id - always uses current user
  // nb_tasks - auto-calculated
  // sales - computed from sales_id
  first_name: string;
  last_name: string;
  gender: string;
  email_jsonb?: string;
  phone_jsonb?: string;
  flat_villa_number?: string;
  building_street?: string;
  area?: string;
  coordinates?: string;
  google_maps_link?: string;
  phone_has_whatsapp?: string;
  services_interested?: string;
  description?: string;
  first_seen: string;
  last_seen: string;
  tags?: string;
  // Legacy fields for backward compatibility
  title?: string;
  company?: string;
  email_work?: string;
  email_home?: string;
  email_other?: string;
  phone_work?: string;
  phone_home?: string;
  phone_other?: string;
  background?: string;
  avatar?: string;
  has_newsletter?: string;
  status?: string;
  linkedin_url?: string;
};

export function useContactImport() {
  const today = new Date().toISOString();
  const user = useGetIdentity();
  const dataProvider = useDataProvider();

  // company cache to avoid creating the same company multiple times and costly roundtrips
  // Cache is dependent of dataProvider, so it's safe to use it as a dependency
  const companiesCache = useMemo(
    () => new Map<string, Company>(),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [dataProvider],
  );
  const getCompanies = useCallback(
    async (names: string[]) =>
      fetchRecordsWithCache<Company>(
        "companies",
        companiesCache,
        names,
        (name) => ({
          name,
          created_at: new Date().toISOString(),
          sales_id: user?.identity?.id,
        }),
        dataProvider,
      ),
    [companiesCache, user?.identity?.id, dataProvider],
  );

  // Tags cache to avoid creating the same tag multiple times and costly roundtrips
  // Cache is dependent of dataProvider, so it's safe to use it as a dependency
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const tagsCache = useMemo(() => new Map<string, Tag>(), [dataProvider]);
  const getTags = useCallback(
    async (names: string[]) =>
      fetchRecordsWithCache<Tag>(
        "tags",
        tagsCache,
        names,
        (name) => ({
          name,
          color: "#f9f9f9",
        }),
        dataProvider,
      ),
    [tagsCache, dataProvider],
  );

  const processBatch = useCallback(
    async (batch: ContactImportSchema[], startRowIndex: number): Promise<ImportError[]> => {
      const errors: ImportError[] = [];
      
      const [companies, tags] = await Promise.all([
        getCompanies(
          batch
            .map((contact) => contact.company?.trim())
            .filter((name) => name),
        ),
        getTags(batch.flatMap((batch) => parseTags(batch.tags))),
      ]);

      const results = await Promise.allSettled(
        batch.map(
          async (row, batchIndex) => {
            const rowNumber = startRowIndex + batchIndex;
            const {
              first_name,
              last_name,
              gender,
              email_jsonb,
              phone_jsonb,
              flat_villa_number,
              building_street,
              area,
              coordinates,
              google_maps_link,
              phone_has_whatsapp,
              services_interested,
              description,
              first_seen,
              last_seen,
              tags: tagNames,
              // Legacy fields for backward compatibility
              title,
              company: companyName,
              email_work,
              email_home,
              email_other,
              phone_work,
              phone_home,
              phone_other,
              background,
              has_newsletter,
              status,
              linkedin_url,
            } = row;
            
            // Ignore id, sales_id, nb_tasks, and sales from CSV - these are auto-generated

            // Parse email_jsonb - support both JSON format and simple email strings
            let parsedEmailJsonb: Array<{ email: string; type: string }> = [];
            if (email_jsonb) {
              try {
                // Try parsing as JSON first (for backward compatibility)
                const parsed = JSON.parse(email_jsonb);
                if (Array.isArray(parsed)) {
                  parsedEmailJsonb = parsed;
                } else {
                  throw new Error("Not an array");
                }
              } catch {
                // If not JSON, treat as simple email string(s) separated by semicolon
                const emailStrings = String(email_jsonb).split(";").map(s => s.trim()).filter(Boolean);
                parsedEmailJsonb = emailStrings.map(email => ({ email, type: "Work" }));
              }
            } else if (email_work || email_home || email_other) {
              // Fall back to legacy fields
              parsedEmailJsonb = [
                { email: email_work, type: "Work" },
                { email: email_home, type: "Home" },
                { email: email_other, type: "Other" },
              ].filter(({ email }) => email);
            }

            // Parse phone_jsonb - support both JSON format and simple phone strings
            let parsedPhoneJsonb: Array<{ number: string; type: string }> = [];
            if (phone_jsonb) {
              try {
                // Try parsing as JSON first (for backward compatibility)
                const parsed = JSON.parse(phone_jsonb);
                if (Array.isArray(parsed)) {
                  parsedPhoneJsonb = parsed;
                } else {
                  throw new Error("Not an array");
                }
              } catch {
                // If not JSON, treat as simple phone string(s) separated by semicolon
                const phoneStrings = String(phone_jsonb).split(";").map(s => s.trim()).filter(Boolean);
                parsedPhoneJsonb = phoneStrings.map(phone => {
                  // Remove quotes, tabs, and spaces (tabs may be added by Excel for text formatting)
                  let formattedPhone = phone.replace(/^["']|["']$/g, "").replace(/[\s\t]/g, ""); // Remove quotes, spaces, and tabs
                  
                  // Handle Excel scientific notation (e.g., "9.71527E+11" -> "971527000000")
                  // Check if it's in scientific notation (contains 'E' or 'e')
                  if (/[eE]/.test(formattedPhone)) {
                    try {
                      // Convert scientific notation to regular number, then to string
                      const num = parseFloat(formattedPhone);
                      if (!isNaN(num)) {
                        formattedPhone = Math.round(num).toString();
                      }
                    } catch {
                      // If conversion fails, keep original
                    }
                  }
                  
                  // Format phone number - add + if it looks like an international number (starts with country code)
                  // Handle numbers like "971551010743" or "971 55 101 0743" or "+971551010743"
                  // If it doesn't start with + and looks like an international number (starts with 1-3 digits), add +
                  if (!formattedPhone.startsWith("+") && /^\d{8,15}$/.test(formattedPhone)) {
                    // Check if it starts with a common country code pattern (1-3 digits)
                    // For UAE (971), add + prefix
                    if (formattedPhone.startsWith("971") || formattedPhone.startsWith("1") || formattedPhone.match(/^\d{10,15}$/)) {
                      formattedPhone = `+${formattedPhone}`;
                    }
                  }
                  return { number: formattedPhone, type: "Work" };
                });
              }
            } else if (phone_work || phone_home || phone_other) {
              // Fall back to legacy fields
              parsedPhoneJsonb = [
                { number: phone_work, type: "Work" },
                { number: phone_home, type: "Home" },
                { number: phone_other, type: "Other" },
              ].filter(({ number }) => number);
            }

            // Parse services_interested (semicolon-separated)
            // Convert to string first in case PapaParse converted it to a number
            const parsedServicesInterested = services_interested
              ? String(services_interested)
                  .split(";")
                  .map((s) => s.trim())
                  .filter(Boolean)
                  .map((s) => parseInt(s, 10))
                  .filter((n) => !isNaN(n))
              : [];

            // Parse coordinates from "lat, lng" format
            let parsedLatitude: number | null = null;
            let parsedLongitude: number | null = null;
            let finalGoogleMapsLink: string | undefined = google_maps_link;
            
            if (coordinates) {
              // Parse from "lat, lng" format
              const parts = String(coordinates).split(",").map((s) => s.trim());
              if (parts.length === 2) {
                const lat = parseFloat(parts[0]);
                const lng = parseFloat(parts[1]);
                if (!isNaN(lat) && !isNaN(lng)) {
                  parsedLatitude = lat;
                  parsedLongitude = lng;
                  // Auto-generate Google Maps link from coordinates if not provided
                  if (!google_maps_link) {
                    finalGoogleMapsLink = `https://www.google.com/maps?q=${lat},${lng}`;
                  }
                }
              }
            }

            const company = companyName?.trim()
              ? companies.get(companyName.trim())
              : undefined;
            const tagList = parseTags(tagNames || "")
              .map((name) => tags.get(name))
              .filter((tag): tag is Tag => !!tag);

            // Always use current user's ID for sales_id (ignore any sales_id in CSV)
            const finalSalesId = user?.identity?.id;

            // Validate required fields
            if (!first_name?.trim() && !last_name?.trim()) {
              throw new Error("Either first_name or last_name is required");
            }

            // Create the contact first
            const contactResponse = await dataProvider.create("contacts", {
              data: {
                first_name,
                last_name,
                gender,
                title,
                email_jsonb: parsedEmailJsonb,
                phone_jsonb: parsedPhoneJsonb,
                flat_villa_number,
                building_street,
                area,
                latitude: parsedLatitude,
                longitude: parsedLongitude,
                google_maps_link: finalGoogleMapsLink,
                phone_has_whatsapp: phone_has_whatsapp === "TRUE" || phone_has_whatsapp === "true",
                services_interested: parsedServicesInterested,
                description,
                background,
                first_seen: first_seen
                  ? new Date(first_seen).toISOString()
                  : today,
                last_seen: last_seen
                  ? new Date(last_seen).toISOString()
                  : today,
                has_newsletter,
                status,
                company_id: company?.id,
                tags: tagList.map((tag) => tag.id),
                sales_id: finalSalesId,
                linkedin_url,
              },
            });

            // Extract contact ID from response (handle both response.data and direct data)
            const contact = ((contactResponse as any)?.data ?? contactResponse) as { id: number | string } | undefined;
            const contactId = contact?.id;

            // Create corresponding lead-journey entry if contact was created successfully
            if (contactId) {
              try {
                await createLeadJourneyDealForContact(
                  dataProvider,
                  {
                    id: contactId,
                    first_name,
                    last_name,
                    sales_id: finalSalesId,
                    company_id: company?.id ?? null,
                  },
                  finalSalesId,
                );
              } catch (error) {
                // Log error but don't fail the import if lead-journey creation fails
                // Using console.error here as logger may not be available in this context
                // eslint-disable-next-line no-console
                console.error("Error creating lead-journey entry for imported contact:", error);
              }
            }

            return contactResponse;
          },
        ),
      );
      
      // Process results and collect errors
      results.forEach((result, index) => {
        if (result.status === "rejected") {
          const rowNumber = startRowIndex + index;
          const errorMessage = result.reason?.message || result.reason || "Unknown error";
          errors.push({
            row: rowNumber,
            message: String(errorMessage),
            data: batch[index],
          });
        }
      });
      
      return errors;
    },
    [dataProvider, getCompanies, getTags, user?.identity?.id, today],
  );

  return processBatch;
}

const fetchRecordsWithCache = async function <T>(
  resource: string,
  cache: Map<string, T>,
  names: string[],
  getCreateData: (name: string) => Partial<T>,
  dataProvider: DataProvider,
) {
  const trimmedNames = [...new Set(names.map((name) => name.trim()))];
  const uncachedRecordNames = trimmedNames.filter((name) => !cache.has(name));

  // check the backend for existing records
  if (uncachedRecordNames.length > 0) {
    const response = await dataProvider.getList(resource, {
      filter: {
        "name@in": `(${uncachedRecordNames
          .map((name) => `"${name}"`)
          .join(",")})`,
      },
      pagination: { page: 1, perPage: trimmedNames.length },
      sort: { field: "id", order: "ASC" },
    });
    for (const record of response.data) {
      cache.set(record.name.trim(), record);
    }
  }

  // create missing records in parallel
  await Promise.all(
    uncachedRecordNames.map(async (name) => {
      if (cache.has(name)) return;
      const response = await dataProvider.create(resource, {
        data: getCreateData(name),
      });
      cache.set(name, response.data);
    }),
  );

  // now all records are in cache, return a map of all records
  return trimmedNames.reduce((acc, name) => {
    acc.set(name, cache.get(name) as T);
    return acc;
  }, new Map<string, T>());
};

const parseTags = (tags: string) =>
  tags
    ? String(tags)
        .split(",")
        .map((tag: string) => tag.trim())
        .filter((tag: string) => tag)
    : [];
